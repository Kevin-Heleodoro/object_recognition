// Author: Kevin Heleodoro
// Date: February 18, 2024
// Purpose: A collection of utils used for object recognition

#include "object_utils.h"

using namespace cv;

////////// Global variables
cv::Mat gray;
cv::Mat dst;

int threshValue = 0;
int const maxVal = 255;
int const maxBinaryValue = 255;
const char *trackbarValue = "Value";

int morphKernelSize = 1;
int maxMorphKernelSize = 25;
const char *morphKernel = "Morph Kernel";

int threshType = 1; // Binary Inverted threshold

int MIN_AREA = 250;

const char *windowDetectName = "Object Detection";
const char *windowName = "Capture";
/////////

void morphologicalFilter(cv::Mat &img, int operation, int kernelSize)
{
    // Create the structuring element for the morphological operation

    /**
     *  cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(kernelSize, kernelSize));
     *  This is the original line of code, but it is not flexible enough to allow for different kernel sizes.
     *  It also does not guarantee that the kernel will be centered.
     */

    cv::Mat element = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(2 * kernelSize + 1, 2 * kernelSize + 1),
                                                cv::Point(kernelSize, kernelSize));

    // Apply the morphological operation
    cv::morphologyEx(img, img, operation, element);
}

void segmentedRegions(const cv::Mat &img)
{
    /**
     * This function is not yet implemented. It is intended to be used to segment the regions of the image
     * that are above the threshold. This was generated by copilot.
     *
        // Find contours
        std::vector<std::vector<cv::Point>> contours;
        std::vector<cv::Vec4i> hierarchy;
        cv::findContours(img, contours, hierarchy, cv::RETR_TREE, cv::CHAIN_APPROX_SIMPLE);

        // Draw contours
        cv::Mat drawing = cv::Mat::zeros(img.size(), CV_8UC3);
        for (size_t i = 0; i < contours.size(); i++)
        {
            cv::Scalar color = cv::Scalar(0, 255, 0);
            cv::drawContours(drawing, contours, (int)i, color, 2, cv::LINE_8, hierarchy, 0);
        }

        // Display the result
        cv::imshow(windowDetectName, drawing);
    */

    // Ensure img has been tresholded
    cv::Mat labels, stats, centroids;
    int nLabels = cv::connectedComponentsWithStats(img, labels, stats, centroids);

    // Create a new image to display the result
    cv::Mat output = cv::Mat::zeros(img.size(), CV_8UC3);

    // Generate random colors for each region
    std::vector<cv::Vec3b> colors(nLabels);
    colors[0] = cv::Vec3b(0, 0, 0); // background
    for (int i = 1; i < nLabels; i++)
    {
        colors[i] = cv::Vec3b(rand() % 256, rand() % 256, rand() % 256);
    }

    // Paint each region with a random color
    for (int i = 0; i < labels.rows; i++)
    {
        for (int j = 0; j < labels.cols; j++)
        {
            int label = labels.at<int>(i, j);
            cv::Vec3b &pixel = output.at<cv::Vec3b>(i, j);
            pixel = colors[label];
        }
    }

    // Filter out small regions
    for (int i = 1; i < nLabels; i++)
    {
        if (stats.at<int>(i, cv::CC_STAT_AREA) < MIN_AREA)
            continue;

        int left = stats.at<int>(i, cv::CC_STAT_LEFT);
        int top = stats.at<int>(i, cv::CC_STAT_TOP);
        int width = stats.at<int>(i, cv::CC_STAT_WIDTH);
        int height = stats.at<int>(i, cv::CC_STAT_HEIGHT);

        // cv::rectangle(output, cv::Rect(left, top, width, height), cv::Scalar(255, 255, 255), 2);
        cv::rectangle(output, cv::Point(left, top), cv::Point(left + width, top + height), cv::Scalar(0, 255, 0));
    }

    // Display the result
    cv::imshow("Connected Components", output);
}

void thresholdDemo(int, void *)
{
    int currentTrackbarValue = cv::getTrackbarPos(trackbarValue, windowName);
    int currentTrackbarMorphKernel = cv::getTrackbarPos(morphKernel, windowName);

    cv::threshold(gray, dst, currentTrackbarValue, maxBinaryValue,
                  threshType); // Will need to make my own custom version eventually

    // Apply morphological opening to reduce noise
    // morphologicalFilter(dst, cv::MORPH_OPEN, 5);

    // Apply morphological closing to fill in gaps
    morphologicalFilter(dst, cv::MORPH_CLOSE, currentTrackbarMorphKernel);

    segmentedRegions(dst);

    // Display the result
    cv::imshow(windowDetectName, dst);
}

int imageThresholding(std::string imgPath)
{
    cv::Mat img = cv::imread(imgPath, cv::IMREAD_COLOR);
    if (img.empty())
    {
        std::cout << "Could not read the image: " << imgPath << std::endl;
        return -1;
    }

    // Convert to grayscale
    cv::cvtColor(img, gray, cv::COLOR_BGR2GRAY);

    // Create a window to display the image
    namedWindow(windowName, cv::WINDOW_AUTOSIZE);

    // Create Trackbar to choose Morph Kernel size
    cv::createTrackbar(morphKernel, windowName, NULL, maxMorphKernelSize, thresholdDemo);
    // Create Trackbar to choose Threshold value
    cv::createTrackbar(trackbarValue, windowName, NULL, maxVal, thresholdDemo);

    // Call the function to initialize
    thresholdDemo(0, 0);

    char key = (char)waitKey(0);
    if (key == 'q')
    {
        std::cout << "User terminated program" << std::endl;
    }
    if (key == 's')
    {
        std::cout << "Saving frame" << std::endl;
        imwrite("frame.png", dst);
    }
    return 0;
}

int videoThresholding()
{
    VideoCapture cap(0);
    if (!cap.isOpened())
    {
        std::cerr << "Error: Could not open camera" << std::endl;
        return -1;
    }

    // Create the input and output windows
    namedWindow(windowName, cv::WINDOW_AUTOSIZE);
    namedWindow(windowDetectName, cv::WINDOW_AUTOSIZE);

    // Create Trackbar to choose Morph Kernel size
    createTrackbar(morphKernel, windowName, NULL, maxMorphKernelSize, thresholdDemo);
    // Create Trackbar to choose Threshold value
    createTrackbar(trackbarValue, windowName, NULL, maxVal, thresholdDemo);

    while (true)
    {
        Mat frame;
        cap >> frame;
        if (frame.empty())
        {
            std::cerr << "Error: Could not capture frame" << std::endl;
            break;
        }

        cvtColor(frame, gray, cv::COLOR_BGR2GRAY);
        thresholdDemo(0, 0);
        imshow(windowName, frame);

        char key = (char)waitKey(30);
        if (key == 'q')
        {
            std::cout << "User terminated program" << std::endl;
            break;
        }
        if (key == 's')
        {
            std::cout << "Saving frame" << std::endl;
            imwrite("frame.png", frame);
        }
    }
    return 0;
}

int customThreshold(const cv::Mat &src, cv::Mat &dst, double threshValue)
{
    // Convert to grayscale
    cv::Mat gray;
    if (src.channels() == 3)
    {
        cv::cvtColor(src, gray, cv::COLOR_BGR2GRAY);
    }
    else
    {
        gray = src.clone();
    }

    // Create destination image and initialize to black
    dst = cv::Mat::zeros(src.size(), CV_8UC1);

    // Apply thresholding
    for (int i = 0; i < gray.rows; i++)
    {
        for (int j = 0; j < gray.cols; j++)
        {
            uchar pixel = gray.at<uchar>(i, j);

            // If the pixel is above the trehsold, set it to white
            if (pixel > threshValue)
            {
                dst.at<uchar>(i, j) = 255;
            }
        }
    }

    return 0;
}
